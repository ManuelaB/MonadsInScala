---
layout: presentation
title: Scala pt. 1
permalink: /02s-fp-1/
---

# Functional Programming in Scala

## Part 1<br>Function evaluation, higher order functions and traits

Korbinian Riedhammer

---

This class is based on the popular Coursera class [Functional Programming Principles in Scala](https://www.coursera.org/learn/progfun1).

---

# Programming Paradigms

A _paradigm_ describes distinct concepts or thought patterns in a certain discipline.

Main programming paradigms:

- imperative programming
- functional programming
- logic programming

> Note: Object-oriented programming is an orthogonal concept

---

# Imperative Programming

...is about

- modifying mutable variables
- using assignments
- control flow instructions (`if-then-else`, `while`, ...)

Think of an instruction sequence for von Neumann computer ("punch cards").

---

# Programming without Mutations

- concentrate on defining theories for operators ("what do they do?")
- minimize state changes
- treat operators as functions (often composed of simpler functions)

---

# Functional Programming

- _strictly speaking_: functional programming (FP) means programming **without** mutable variables, assignments, loops and other imperative control structures
- _more casual_: FP means focusing on the functions (instead of the objects)
- functions can be values that are produced, consumed and composed
- ...use a _functional language_

---

# Functional Programming Languages

- _strictly speaking_: a language that does not have mutable variables, assignments or control structures
- _more casual_: syntax that comforts working with functions
- functions are "first class citizens", ie.
    + can be defined anywhere, including inside other functions
    + can be passed as parameters or returned as results
    + operators that work ontop of functions
- Examples:
    + strict: Pure Lisp, XSLT, XPATH, Haskell
    + casual: Lisp, Scheme, Clojure, Scala

---

# Why Functional Programming?

FP is all about immutable objects.

As a result: much easier to parallelize (think map-reduce)

---

# Elements of Programming

Every non-trivial programming language provides:
- primitive _expressions_ representing the simplest elements
- means to _combine_ expressions
- means to _abstract_ expressions

---

# Expressions

```scala
scala> 17
17

scala> 17 + 4
21

scala> def x = 5
x: Int

scala> def square(x: Double) = x * x
square: (x: Double)Double

scala> def add(x: Double, y: Double): Double = x + y
add: (x: Double, y: Double)Double

scala> def addsquares(x: Double, y: Double): Double = square(x) + square(y)
addsquares: (x: Double, y: Double)Double
```

Use `def` to define values and functions.
- primitive types as in Java, but capitalized (`Int`, `Double`, ...)
- return type can be inferred automatically
- type follows argument name (and optionally function)

---

# Evaluating Expressions

Non-primitive expressions are evaluated as

1. take leftmost operator
2. evaluate its operands (left before right)
3. apply the operator to the operands

```scala
2 * pi * radius
2 * 3.1415 * radius
6.283 * radius
6.283 * 10.0
62.83
```

---

# Evaluating Function Applications

Applications of parameterized functions are evaluated as

1. evaluate all function arguments, left-to-right
2. replace the function application by the function's right-hand side, and,
3. replace the formal parameters of the function by the actual arguments

```scala
addsquares(3, 1+1)
addsquares(3, 2)
square(3) + square(2)
3 * 3 + square(2)
9 + square(2)
9 + 2 * 2
9 + 4
13
```

---

# The Substitution Model

This scheme of expression evaluation is called _substitution model_.

The idea is to _reduce an expression to a value_.

Can be applied to all expressions -- as long as they have no side effects (immutable!)

???

lambda calculus

---
